<!DOCTYPE html>
<html lang="es">
<head>
    
  <meta charset="utf-8" />
  <title>CHATBOT para uso de los CSV de Consumertec</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PapaParse para procesar CSV en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js para los gráficos de la sección 7 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- jsPDF para generar el PDF de las secciones 6 y 7 -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --card:#020617;
      --border:#1f2937;
      --accent:#22d3ee;
      --accent2:#4ade80;
      --text:#e5e7eb;
      --muted:#9ca3af;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617);
      color:var(--text);
      padding:10px;
    }
    .card{
      width:min(1100px,100%);
      max-height:96vh;
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 20px;
      box-shadow:0 22px 50px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
    }
    h1{
      font-size:1.7rem;
      text-align:center;
      margin-bottom:4px;
    }
    p{
      font-size:0.9rem;
      line-height:1.5;
      color:var(--muted);
      text-align:justify;
      text-justify:inter-word;
    }
    .section-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:4px;
      margin-top:8px;
    }
    label{
      font-size:0.85rem;
      margin-bottom:4px;
      display:block;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:#020617;
      color:var(--muted);
      font-size:0.85rem;
    }
    /* NUEVO: campos de texto y selects */
    input[type="text"],
    select{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      font-size:0.85rem;
    }
    textarea{
      width:100%;
      min-height:90px;
      max-height:200px;
      resize:vertical;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      padding:8px 10px;
      font-size:0.85rem;
      line-height:1.4;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:6px;
      align-items:center;
    }
    .row > *{
      flex:1 1 auto;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 16px;
      border-radius:999px;
      text-decoration:none;
      border:none;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      font-weight:600;
      font-size:0.85rem;
      letter-spacing:0.02em;
      cursor:pointer;
      transition:transform 0.1s ease, filter 0.1s ease;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#111827;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .btn:hover{
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .status{
      font-size:0.83rem;
      color:var(--muted);
      margin-top:4px;
    }
    .output-box{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      font-size:0.83rem;
      line-height:1.45;
      max-height:260px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .small{
      font-size:0.8rem;
      color:var(--muted);
    }
    .mode-options{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .mode-group{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }
    .mode-group.hidden{
      display:none;
    }
    .mode-group.disabled{
      opacity:0.3;
      pointer-events:none;
    }
    .mode-options label{
      display:flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      font-size:0.85rem;
    }
    .mode-options input[type="radio"]{
      accent-color:#22d3ee;
      width:16px;
      height:16px;
    }
    /* Sección 6: más alta y scrollbar garantizado para textos largos */
    #textOutput{
      max-height:60vh;
      overflow-y:auto;
    }
    /* NUEVO: contenedor gráfico sección 7 */
    .chart-wrapper{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      height:260px;
    }
    #chartCanvas{
      width:100%;
      height:100%;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>CHATBOT para uso de los CSV de Consumertec</h1>
    <p>
      Este chatbot está diseñado para trabajar con archivos <strong>OUTPUT_MAP_COMPARISONS.csv</strong> y
      otros CSV derivados de los experimentos de Consumertec. Primero se <strong>sube en la sección 1</strong>
      el archivo CSV que se desea analizar. A partir de su estructura, en la <strong>sección 2</strong> se
      activan los <strong>prompts internos</strong> compatibles (comparaciones, blancura, resumen general,
      relación de RESPONSE con las demás columnas o sus variantes avanzadas). Después se ejecuta el análisis:
      el sistema genera un <strong>resumen numérico en el navegador (sección 5)</strong> para que puedas ver
      la foto técnica de la tabla, y la explicación extensa de la <strong>sección 6</strong> se construye
      a partir de <strong>métricas estructuradas</strong> calculadas en la sección 5 (no texto libre).
    </p>

    <!-- Estado del motor -->
    <div id="llmStatus" class="status small">
      ✅ Sección 5 calcula métricas (tasas, contextos críticos, distribuciones).
      ✅ Sección 6 se genera en el backend por /build_section6 usando JSON estructurado (sin imprimir prompts/mandatos).
    </div>
    <!-- Subir CSV (SECCIÓN 1) -->
    <div>
      <div class="section-title">1. Subir archivo CSV</div>
      <label for="csvInput" id="csvLabel">
        Sube primero el CSV que quieres analizar. Según sus columnas, se activarán las opciones de análisis en la sección 2.
      </label>
      <input id="csvInput" type="file" accept=".csv" />
      <div id="fileStatus" class="status">⚠️ Ningún archivo seleccionado.</div>
    </div>

    <!-- Elegir tipo de análisis + prompt interno (SECCIÓN 2) -->
    <div>
      <div class="section-title">2. Elegir tipo de análisis y prompt interno</div>
      <p class="small">
        Después de subir el CSV, se mostrarán aquí los tipos de análisis compatibles. Cada tipo activa sus
        prompts internos. El prompt seleccionado se mostrará en la <strong>sección 3</strong> (puedes editarlo),
        pero la sección 6 NO imprime mandatos: el backend genera un texto técnico a partir de métricas estructuradas.
      </p>

      <div class="mode-options">
        <!-- Grupo Comparaciones -->
        <div id="group_comparaciones" class="mode-group hidden">
          <label>
            <input id="mode_comparaciones_basico" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_basico')" />
            Prompt 1 — Comparación (PRODUCT_TEST vs RESPONSE)
          </label>
          <label>
            <input id="mode_comparaciones_escenarios" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_escenarios')" />
            Prompt 5 — Comparación por escenarios y modalidades
          </label>
        </div>

        <!-- Grupo Blancura -->
        <div id="group_whiteness" class="mode-group hidden">
          <label>
            <input id="mode_whiteness_basico" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_basico')" />
            Prompt 2 — Blancura por MONITOR (métricas WI)
          </label>
          <label>
            <input id="mode_whiteness_productos" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_productos')" />
            Prompt 6 — Perfil de blancura por producto
          </label>
        </div>

        <!-- Grupo Resumen -->
        <div id="group_resumen" class="mode-group hidden">
          <label>
            <input id="mode_resumen_basico" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_basico')" />
            Prompt 3 — Resumen general de la tabla
          </label>
          <label>
            <input id="mode_resumen_avanzado" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_avanzado')" />
            Prompt 7 — Resumen avanzado y bloques de variables
          </label>
        </div>

        <!-- Grupo RESPONSE vs otras columnas -->
        <div id="group_response_rel" class="mode-group hidden">
          <label>
            <input id="mode_response_basico" type="radio" name="mode"
                   onclick="setMode('response_rel','response_basico')" />
            Prompt 4 — Comparar RESPONSE con las demás columnas
          </label>
          <label>
            <input id="mode_response_extremos" type="radio" name="mode"
                   onclick="setMode('response_rel','response_extremos')" />
            Prompt 8 — RESPONSE: mejores y peores resultados
          </label>
        </div>
      </div>

      <div class="status small" id="modeStatus">
        Primero sube un CSV en la sección 1. Luego se activarán aquí los tipos de análisis compatibles.
      </div>
    </div>
    <!-- Pregunta / Prompt (SECCIÓN 3) -->
    <div>
      <div class="section-title">3. Prompt de análisis</div>
      <label for="question">
        El prompt se rellena automáticamente según el análisis elegido, pero puedes editarlo.
        Nota: la sección 6 NO imprime este texto. Se usa solo como metadato (prompt_key/prompt_text).
      </label>
      <textarea id="question" placeholder="Sube un CSV y elige un tipo de análisis; aquí aparecerá el prompt asociado, que podrás ajustar…"></textarea>
      <div class="row">
        <button class="btn" type="button" onclick="analizarCSV()">
          4. Analizar CSV
        </button>
      </div>
      <div id="analysisStatus" class="status">
        ⏳ Sube un CSV, elige un tipo de análisis en la sección 2 y luego usa el botón Analizar.
      </div>
    </div>

    <!-- Resultados de cómputo -->
    <div>
      <div class="section-title">5. Resultados numéricos (resumen técnico)</div>
      <div id="numericOutput" class="output-box small">
        // Aquí aparecerán tablas de conteos, tasas, contextos críticos, etc. (cálculo interno en el navegador).
      </div>
    </div>

    <!-- Explicación en texto continuo -->
    <div>
      <div class="section-title">6. Explicación en texto continuo (respuesta extendida)</div>
      <div id="textOutput" class="output-box">
        // Aquí se generará una explicación automática extensa producida por el backend /build_section6 usando JSON estructurado.
      </div>

      <div class="row">
        <div>
          <label for="reportTitle" class="small">
            Título del reporte (se usará como título en el PDF y en el nombre del archivo)
          </label>
          <input id="reportTitle"
                 type="text"
                 placeholder="Ejemplo: Informe de desempeño de productos Consumertec" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn secondary" type="button" onclick="descargarPDF()">
            Descargar secciones 6 y 7 (.pdf)
          </button>
        </div>
      </div>
    </div>
    <!-- NUEVA SECCIÓN 7: gráficos a partir del resumen numérico -->
    <div>
      <div class="section-title">7. Visualización gráfica de los resultados</div>
      <p class="small">
        Estos gráficos se generan automáticamente a partir del resumen numérico de la sección 5.
        Después de ejecutar un análisis, puedes elegir si ver el gráfico en barras o en líneas.
      </p>
      <div class="row">
        <div>
          <label for="chartType">Tipo de gráfico</label>
          <select id="chartType" onchange="cambiarTipoGrafico()">
            <option value="bar">Barras</option>
            <option value="line">Líneas</option>
          </select>
        </div>
        <div id="chartStatus" class="status">
          ⚠️ Aún no hay datos para graficar. Ejecuta un análisis primero.
        </div>
      </div>
      <div class="chart-wrapper">
        <canvas id="chartCanvas"></canvas>
      </div>

      <!-- segundo gráfico multivariable -->
      <div id="chartMultiStatus" class="status">
        ⚠️ Aún no hay datos para el gráfico multivariable. Ejecuta un análisis compatible.
      </div>
      <div class="chart-wrapper">
        <canvas id="chartCanvasMulti"></canvas>
      </div>
    </div>
  </div>
  <!-- Lógica: CSV + análisis interno + backend section6 + gráficos + PDF -->
  <script>
    // ============================================================
    //  Backend Section6 (FastAPI) para sección 6
    //  CAMBIO CLAVE: ahora usamos /build_section6 (no /generate_answer)
    // ============================================================
    const BACKEND_URL = "https://alexacido-consumertec-llm.hf.space/build_section6";

    // -------------------------------------------------------------
    // Estado global
    // -------------------------------------------------------------
    let csvFile = null;
    let csvHeaders = null;
    let analysisMode = null;       // 'comparaciones', 'whiteness', 'resumen', 'response_rel'
    let currentPromptKey = null;   // identifica el prompt específico

    // estado gráfico
    let chartInstance = null;
    let lastChartData = null;

    // estado gráfico multivariable
    let chartInstanceMulti = null;
    let lastChartDataMulti = null;

    // Tipos de análisis detectados como compatibles
    const tiposDisponibles = {
      comparaciones: false,
      whiteness: false,
      resumen: false,
      response_rel: false
    };

    const whitenessMetrics = [
      "1.2.WI_STw",
      "2.2.WI_GEw",
      "3.2.WI_VOw",
      "4.2.WI_LGw"
    ];

    const csvInputEl   = document.getElementById("csvInput");
    const fileStatusEl = document.getElementById("fileStatus");
    const csvLabelEl   = document.getElementById("csvLabel");
    const modeStatusEl = document.getElementById("modeStatus");
    // -------------------------------------------------------------
    // Helpers para sección 7 (gráficos)
    // -------------------------------------------------------------
    function prepararDatosGrafico(data) {
      lastChartData = data || null;
      const chartStatusEl = document.getElementById("chartStatus");
      if (!lastChartData || !lastChartData.labels || !lastChartData.labels.length) {
        if (chartStatusEl) chartStatusEl.textContent = "⚠️ No se generaron datos suficientes para graficar.";
        if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
        return;
      }
      if (chartStatusEl) {
        chartStatusEl.textContent = "✅ Datos listos para graficar: " + (lastChartData.title || "gráfico.");
      }
      renderChartInternal();
    }

    function renderChartInternal() {
      const canvas = document.getElementById("chartCanvas");
      const chartTypeEl = document.getElementById("chartType");
      const chartStatusEl = document.getElementById("chartStatus");

      if (!canvas || !lastChartData || !lastChartData.labels || !lastChartData.labels.length) {
        if (chartStatusEl) chartStatusEl.textContent = "⚠️ Aún no hay datos para graficar. Ejecuta un análisis primero.";
        return;
      }

      const ctx = canvas.getContext("2d");
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }

      const tipo = chartTypeEl ? chartTypeEl.value : "bar";

      chartInstance = new Chart(ctx, {
        type: tipo,
        data: {
          labels: lastChartData.labels,
          datasets: [{
            label: lastChartData.datasetLabel || "Valores",
            data: lastChartData.values,
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            title: { display: !!lastChartData.title, text: lastChartData.title }
          },
          scales: {
            x: {
              title: { display: !!lastChartData.xLabel, text: lastChartData.xLabel },
              ticks: { autoSkip: true, maxRotation: 45, minRotation: 0 }
            },
            y: {
              beginAtZero: true,
              title: { display: !!lastChartData.yLabel, text: lastChartData.yLabel }
            }
          }
        }
      });

      if (chartStatusEl) chartStatusEl.textContent = "✅ Gráfico actualizado correctamente.";
    }

    function cambiarTipoGrafico() { renderChartInternal(); }
    window.cambiarTipoGrafico = cambiarTipoGrafico;

    // -------------------------------------------------------------
    // Helpers para gráfico multivariable
    // -------------------------------------------------------------
    function prepararDatosGraficoMultivariable(data) {
      lastChartDataMulti = data || null;
      const chartMultiStatusEl = document.getElementById("chartMultiStatus");

      if (!lastChartDataMulti || !lastChartDataMulti.labels || !lastChartDataMulti.labels.length ||
          !lastChartDataMulti.datasets || !lastChartDataMulti.datasets.length) {
        if (chartMultiStatusEl) chartMultiStatusEl.textContent = "⚠️ No se generaron datos suficientes para el gráfico multivariable.";
        if (chartInstanceMulti) { chartInstanceMulti.destroy(); chartInstanceMulti = null; }
        return;
      }

      if (chartMultiStatusEl) {
        chartMultiStatusEl.textContent = "✅ Datos listos para el gráfico multivariable: " + (lastChartDataMulti.title || "gráfico multivariable.");
      }

      renderChartMultivariable();
    }

    function renderChartMultivariable() {
      const canvas = document.getElementById("chartCanvasMulti");
      const chartMultiStatusEl = document.getElementById("chartMultiStatus");

      if (!canvas || !lastChartDataMulti || !lastChartDataMulti.labels || !lastChartDataMulti.labels.length ||
          !lastChartDataMulti.datasets || !lastChartDataMulti.datasets.length) {
        if (chartMultiStatusEl) chartMultiStatusEl.textContent = "⚠️ Aún no hay datos para el gráfico multivariable.";
        return;
      }

      const ctx = canvas.getContext("2d");
      if (chartInstanceMulti) { chartInstanceMulti.destroy(); chartInstanceMulti = null; }

      chartInstanceMulti = new Chart(ctx, {
        type: "bar",
        data: {
          labels: lastChartDataMulti.labels,
          datasets: lastChartDataMulti.datasets.map(ds => ({
            label: ds.label,
            data: ds.values,
            fill: false
          }))
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            title: { display: !!lastChartDataMulti.title, text: lastChartDataMulti.title }
          },
          scales: {
            x: {
              title: { display: !!lastChartDataMulti.xLabel, text: lastChartDataMulti.xLabel },
              ticks: { autoSkip: true, maxRotation: 45, minRotation: 0 }
            },
            y: {
              beginAtZero: true,
              title: { display: !!lastChartDataMulti.yLabel, text: lastChartDataMulti.yLabel }
            }
          }
        }
      });

      if (chartMultiStatusEl) chartMultiStatusEl.textContent = "✅ Gráfico multivariable actualizado correctamente.";
    }
    // -------------------------------------------------------------
    // Actualizar visibilidad de grupos de prompts
    // -------------------------------------------------------------
    function actualizarDisponibilidadPrompts() {
      const groupCompar = document.getElementById("group_comparaciones");
      const groupWhite  = document.getElementById("group_whiteness");
      const groupRes    = document.getElementById("group_resumen");
      const groupResp   = document.getElementById("group_response_rel");

      if (tiposDisponibles.comparaciones) groupCompar.classList.remove("hidden");
      else groupCompar.classList.add("hidden");

      if (tiposDisponibles.whiteness) groupWhite.classList.remove("hidden");
      else groupWhite.classList.add("hidden");

      if (tiposDisponibles.resumen) groupRes.classList.remove("hidden");
      else groupRes.classList.add("hidden");

      if (tiposDisponibles.response_rel) groupResp.classList.remove("hidden");
      else groupResp.classList.add("hidden");

      const activos = [];
      if (tiposDisponibles.comparaciones) activos.push("Comparaciones PRODUCT_TEST vs RESPONSE");
      if (tiposDisponibles.whiteness)     activos.push("Blancura por MONITOR (métricas WI)");
      if (tiposDisponibles.resumen)      activos.push("Resumen general / avanzado");
      if (tiposDisponibles.response_rel) activos.push("RESPONSE vs otras columnas");

      if (!csvFile) {
        modeStatusEl.textContent =
          "Primero sube un CSV en la sección 1. Luego se activarán aquí los tipos de análisis compatibles.";
      } else if (!activos.length) {
        modeStatusEl.textContent =
          "CSV cargado, pero no se detectó ninguna configuración estándar. Puedes seguir usando un resumen general con el modo Resumen.";
      } else {
        modeStatusEl.textContent =
          "CSV cargado. Análisis disponibles: " + activos.join(" • ") +
          ". La sección 5 mostrará el resumen numérico y la 6 la interpretación del backend /build_section6.";
      }
    }

    actualizarDisponibilidadPrompts();

    // -------------------------------------------------------------
    // Manejo de subida de archivo
    // -------------------------------------------------------------
    csvInputEl.addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];

      csvFile = null;
      csvHeaders = null;
      analysisMode = null;
      currentPromptKey = null;
      document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });

      const questionEl = document.getElementById("question");
      questionEl.value = "";
      questionEl.placeholder =
        "Tras subir el CSV y elegir un tipo de análisis en la sección 2, aquí se cargará el prompt correspondiente…";

      // Reset gráficos
      lastChartData = null;
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      const chartStatusEl = document.getElementById("chartStatus");
      if (chartStatusEl) chartStatusEl.textContent = "⚠️ Aún no hay datos para graficar. Ejecuta un análisis primero.";

      lastChartDataMulti = null;
      if (chartInstanceMulti) { chartInstanceMulti.destroy(); chartInstanceMulti = null; }
      const chartMultiStatusEl = document.getElementById("chartMultiStatus");
      if (chartMultiStatusEl) chartMultiStatusEl.textContent = "⚠️ Aún no hay datos para el gráfico multivariable. Ejecuta un análisis compatible.";

      if (!file) {
        fileStatusEl.textContent = "⚠️ Ningún archivo seleccionado.";
        tiposDisponibles.comparaciones = false;
        tiposDisponibles.whiteness = false;
        tiposDisponibles.resumen = false;
        tiposDisponibles.response_rel = false;
        actualizarDisponibilidadPrompts();
        return;
      }

      fileStatusEl.textContent =
        "⏳ Leyendo archivo: " + file.name + " (" + formatBytes(file.size) + ")…";

      Papa.parse(file, {
        header: true,
        preview: 5,
        skipEmptyLines: true,
        complete: function(results) {
          const headers = results.meta && results.meta.fields ? results.meta.fields : [];
          csvHeaders = headers;

          const validCompar   = validarHeadersPorModo("comparaciones", headers);
          const validWhite    = validarHeadersPorModo("whiteness", headers);
          const validResumen  = validarHeadersPorModo("resumen", headers);
          const validRespRel  = validarHeadersPorModo("response_rel", headers);

          tiposDisponibles.comparaciones = !!validCompar.ok;
          tiposDisponibles.whiteness     = !!validWhite.ok;
          tiposDisponibles.resumen       = !!validResumen.ok;
          tiposDisponibles.response_rel  = !!validRespRel.ok;

          csvFile = file;

          const disponibles = [];
          if (validCompar.ok)  disponibles.push("Comparación PRODUCT_TEST vs RESPONSE");
          if (validWhite.ok)   disponibles.push("Blancura por MONITOR (métricas WI)");
          if (validRespRel.ok) disponibles.push("RESPONSE vs otras columnas");
          if (validResumen.ok) disponibles.push("Resumen general / avanzado");

          fileStatusEl.textContent =
            "✅ CSV cargado: " + file.name + " (" + formatBytes(file.size) + "). " +
            (disponibles.length
              ? "Análisis posibles: " + disponibles.join(" • ") + "."
              : "Puedes usar un resumen general con el modo Resumen.");

          csvLabelEl.textContent =
            "Archivo CSV cargado. Si lo deseas, puedes cambiarlo por otro. Ahora elige en la sección 2 el tipo de análisis.";

          actualizarDisponibilidadPrompts();
        },
        error: function(err) {
          csvFile = null;
          csvHeaders = null;
          fileStatusEl.textContent = "❌ Error al leer el CSV: " + err;
          tiposDisponibles.comparaciones = false;
          tiposDisponibles.whiteness = false;
          tiposDisponibles.resumen = false;
          tiposDisponibles.response_rel = false;
          actualizarDisponibilidadPrompts();
        }
      });
    });

    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B","KB","MB","GB","TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }
    // -------------------------------------------------------------
    // Validación de columnas según modo
    // -------------------------------------------------------------
    function validarHeadersPorModo(mode, headers) {
      const hdr = headers || [];
      const set = new Set(hdr);

      if (mode === "comparaciones") {
        const needed = ["PRODUCT_TEST", "RESPONSE"];
        const faltantes = needed.filter(c => !set.has(c));
        if (faltantes.length > 0) {
          return { ok: false, mensaje: "faltan columnas (" + faltantes.join(", ") + ")." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "whiteness") {
        const base = ["MONITOR", "PRODUCT"];
        const faltantesBase = base.filter(c => !set.has(c));
        if (faltantesBase.length > 0) {
          return { ok: false, mensaje: "faltan columnas base " + faltantesBase.join(", ") + "." };
        }
        const algunaMetrica = whitenessMetrics.some(m => set.has(m));
        if (!algunaMetrica) {
          return { ok: false, mensaje: "no se encontró ninguna métrica WI esperada." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "resumen") {
        if (!hdr.length) return { ok: false, mensaje: "el CSV no tiene columnas detectables." };
        return { ok: true, mensaje: "" };
      }

      if (mode === "response_rel") {
        if (!set.has("RESPONSE")) return { ok: false, mensaje: "no se encuentra RESPONSE." };
        return { ok: true, mensaje: "" };
      }

      return { ok: false, mensaje: "modo no reconocido." };
    }

    // -------------------------------------------------------------
    // Selección de prompt interno
    // -------------------------------------------------------------
    function setModeInternal(mode, promptKey) {
      const llmStatusEl = document.getElementById("llmStatus");
      const questionEl  = document.getElementById("question");

      if (!csvFile) {
        modeStatusEl.textContent = "⚠️ Primero sube un CSV en la sección 1.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      if (mode === "comparaciones" && !tiposDisponibles.comparaciones) {
        modeStatusEl.textContent = "❌ CSV no compatible con Comparaciones (PRODUCT_TEST/RESPONSE).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "whiteness" && !tiposDisponibles.whiteness) {
        modeStatusEl.textContent = "❌ CSV no compatible con Blancura (MONITOR/PRODUCT/WI).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "resumen" && !tiposDisponibles.resumen) {
        modeStatusEl.textContent = "❌ CSV no compatible con Resumen.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "response_rel" && !tiposDisponibles.response_rel) {
        modeStatusEl.textContent = "❌ CSV no contiene RESPONSE.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      analysisMode = mode;
      currentPromptKey = promptKey || mode;

      questionEl.placeholder = "Prompt cargado (no se imprimirá en sección 6). Puedes editarlo si lo deseas…";

      // === TEXTOS DE LOS PROMPTS INTERNOS (igual que tenías) ===
      if (mode === "comparaciones") {
        if (currentPromptKey === "comparaciones_basico") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv para identificar cuál es el producto con mejor desempeño general. Para ello, toma en cuenta únicamente las comparaciones en las que la columna RESPONSE tenga los valores 01.SUPERIOR o 02.SUPERIOR_TREND, que indican un resultado favorable para PRODUCT_TEST frente a PRODUCT_BENCH. Evalúa cuántas veces cada valor de PRODUCT_TEST alcanza un resultado superior en todas las combinaciones posibles de las columnas MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. El producto que más veces obtenga resultados favorables según estos dos valores de RESPONSE debe ser considerado como el de mejor desempeño. La conclusión debe presentarse en texto continuo, indicando claramente cuál es el producto con mejor rendimiento y por qué, basándose en la frecuencia con la que obtiene un desempeño superior en las comparaciones.`;
        } else if (currentPromptKey === "comparaciones_escenarios") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv poniendo el foco en cómo cambia el desempeño de los distintos PRODUCT_TEST según las columnas MODALITY, SCENARIOS, WASH y PROCESS. Identifica para cada una de estas columnas qué productos tienden a concentrar más respuestas 01.SUPERIOR y 02.SUPERIOR_TREND, señalando si hay formulaciones especialmente fuertes en determinados escenarios o modalidades y si existen contextos donde el rendimiento se reparte de forma más equilibrada. La explicación debe ser en texto continuo, resaltando las combinaciones producto–escenario más robustas y aquellas donde las diferencias entre productos parecen menos marcadas.`;
        }
      } else if (mode === "whiteness") {
        if (currentPromptKey === "whiteness_basico") {
          questionEl.value =
`Para cada uno de los valores únicos de la columna "MONITOR", identifica cuáles son los productos ("PRODUCT") que presentan los valores más altos en cada una de las métricas de blancura: "1.2.WI_STw" (blancura estándar), "2.2.WI_GEw" (blancura verdosa), "3.2.WI_VOw" (blancura violácea) y "4.2.WI_LGw" (blancura luminosa). Para cada caso, indica en qué combinaciones específicas de las variables "MODALITY", "SCENARIOS", "WASH" y "PROCESS" se presentan esos valores máximos. Luego, compara entre los distintos productos dentro de cada tipo de monitor, resaltando si algún producto se destaca de forma consistente en más de una métrica o en múltiples combinaciones. Finalmente, resume qué productos muestran un mejor desempeño global de blancura en función del tipo de monitor utilizado, considerando la frecuencia con la que aparecen con los valores más altos y la diversidad de condiciones en las que lo hacen.`;
        } else if (currentPromptKey === "whiteness_productos") {
          questionEl.value =
`Utiliza los datos de blancura del CSV para construir un perfil de cada "PRODUCT" en términos de las métricas "1.2.WI_STw", "2.2.WI_GEw", "3.2.WI_VOw" y "4.2.WI_LGw" a través de todos los "MONITOR" disponibles. Describe en texto continuo qué productos se ubican con mayor frecuencia en los valores máximos de blancura, cuáles parecen más equilibrados entre varias métricas y cuáles destacan solo en una dimensión específica (por ejemplo, más verdosa o más luminosa). Indica también si hay productos que cambian mucho su posición relativa según el monitor utilizado, y qué implicaciones tiene esto para la lectura global de blancura.`;
        }
      } else if (mode === "resumen") {
        if (currentPromptKey === "resumen_basico") {
          questionEl.value =
`Haz un resumen general de la tabla del CSV, describiendo cuántas filas y columnas contiene, qué tipo de información parece dominar (columnas numéricas frente a categóricas) y cómo se distribuyen los valores. Menciona, de forma interpretativa, cuáles son las columnas que parecen más relevantes o más variadas y qué patrones generales se pueden intuir solamente a partir de los recuentos y de los rangos de valores. La explicación debe ir en texto continuo, sin listas, destacando las ideas principales sobre la estructura y el contenido de la tabla.`;
        } else if (currentPromptKey === "resumen_avanzado") {
          questionEl.value =
`Elabora un resumen avanzado de la tabla combinando la descripción estructural (número de filas, columnas y tipos de variables) con una lectura más interpretativa de qué grupos de columnas parecen estar relacionados entre sí. Sin realizar inferencias causales, comenta qué bloques de variables pueden agruparse (por ejemplo, columnas de contexto experimental frente a columnas de resultados) y cómo podrían utilizarse en análisis posteriores más específicos. La explicación debe ser narrativa, destacando las conexiones más plausibles sólo a partir de la estructura y de los recuentos.`;
        }
      } else if (mode === "response_rel") {
        if (currentPromptKey === "response_basico") {
          questionEl.value =
`Compara la distribución de los valores de la columna RESPONSE con lo que ocurre en el resto de columnas del CSV. Identifica qué valores de RESPONSE son más frecuentes y, para cada uno de ellos, describe qué patrones se observan en las columnas principales (productos, monitores, modalidades, escenarios, procesos, etc.). Explica de forma narrativa si hay combinaciones de valores que aparezcan más asociadas a determinados resultados de RESPONSE, resaltando las tendencias más claras que puedan deducirse únicamente de los recuentos.`;
        } else if (currentPromptKey === "response_extremos") {
          questionEl.value =
`Profundiza en la columna RESPONSE distinguiendo claramente entre los resultados más favorables y los menos favorables. Para cada grupo (por ejemplo, valores que representan superioridad, empate o inferioridad), describe qué patrones se observan en las columnas de producto, monitor, modalidad y escenario. Explica en texto continuo qué combinaciones parecen asociarse con respuestas especialmente buenas y cuáles tienden a concentrar los peores resultados, utilizando únicamente recuentos y frecuencias obtenidos del CSV.`;
        }
      }


      modeStatusEl.textContent = "✅ Prompt interno seleccionado (sección 6 usa métricas estructuradas).";
      if (llmStatusEl) {
        llmStatusEl.textContent =
          "✅ Sección 5 calcula métricas estructuradas. ✅ Sección 6 se genera en /build_section6 y NO imprime mandatos/prompt.";
      }
    }

    window.setMode = setModeInternal;
    // -------------------------------------------------------------
    // Llamada al backend /build_section6 (STRUCTURED)
    // -------------------------------------------------------------
    async function pedirExplicacionDesdeBackendStructured(payloadObj) {
      const textEl = document.getElementById("textOutput");
      const llmStatusEl = document.getElementById("llmStatus");
      if (!textEl) return;

      textEl.textContent = "⏳ Llamando al backend /build_section6…";

      try {
        const resp = await fetch(BACKEND_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payloadObj || {})
        });

        if (!resp.ok) {
          const msg = "Respuesta HTTP no OK: " + resp.status;
          console.error(msg);
          textEl.textContent =
            "❌ Error llamando al backend.\n" + msg + "\n\n" +
            "Verifica que el endpoint sea /build_section6 y que el Space esté activo.";
          if (llmStatusEl) llmStatusEl.textContent = "❌ Backend respondió con error " + resp.status + ".";
          return;
        }

        const data = await resp.json();
        const out = (data && data.section6_text) ? String(data.section6_text).trim() : "";

        if (!out) {
          textEl.textContent =
            "⚠️ El backend no devolvió section6_text.\n" +
            "Revisa que tu app.py retorne {section6_text: ...}.";
          if (llmStatusEl) llmStatusEl.textContent = "⚠️ Backend sin section6_text.";
        } else {
          textEl.textContent = out;
          if (llmStatusEl) llmStatusEl.textContent = "✅ Sección 6 generada por /build_section6 (payload estructurado).";
        }
      } catch (err) {
        console.error("Error llamando al backend:", err);
        textEl.textContent =
          "❌ Error de red al llamar al backend /build_section6.\n" +
          "Revisa conexión y estado del Space.";
        if (llmStatusEl) llmStatusEl.textContent = "❌ Error de red hacia el backend.";
      }
    }

    // -------------------------------------------------------------
    // Botón principal: analizar CSV
    // -------------------------------------------------------------
    function analizarCSVInternal() {
      const statusEl  = document.getElementById("analysisStatus");
      const numericEl = document.getElementById("numericOutput");
      const textEl    = document.getElementById("textOutput");
      const question  = document.getElementById("question").value.trim();

      if (!csvFile) { statusEl.textContent = "⚠️ Sube primero el CSV."; return; }
      if (!analysisMode) { statusEl.textContent = "⚠️ Elige un tipo de análisis en la sección 2."; return; }
      if (!question) { statusEl.textContent = "⚠️ El prompt (sección 3) no puede estar vacío."; return; }

      statusEl.textContent = "⏳ Analizando CSV (sección 5) y preparando payload estructurado para sección 6…";
      numericEl.textContent = "// Procesando CSV para generar el resumen técnico…";
      textEl.textContent = "// Esperando respuesta del backend (sección 6)…";

      // Reset gráficos
      lastChartData = null;
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      const chartStatusEl = document.getElementById("chartStatus");
      if (chartStatusEl) chartStatusEl.textContent = "⏳ Preparando datos para posibles gráficos…";

      lastChartDataMulti = null;
      if (chartInstanceMulti) { chartInstanceMulti.destroy(); chartInstanceMulti = null; }
      const chartMultiStatusEl = document.getElementById("chartMultiStatus");
      if (chartMultiStatusEl) chartMultiStatusEl.textContent = "⏳ Preparando datos para el gráfico multivariable…";

      if (analysisMode === "whiteness") {
        analizarBlancura(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "comparaciones") {
        analizarComparaciones(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "resumen") {
        analizarResumen(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "response_rel") {
        analizarResponseVsOtros(statusEl, numericEl, textEl, question);
      }
    }

    window.analizarCSV = analizarCSVInternal;
// -------------------------------------------------------------
// Modo 1: Comparaciones (igual a tu lógica, pero ahora ENVÍA payload estructurado)
// -------------------------------------------------------------
function analizarComparaciones(statusEl, numericEl, textEl, userPrompt) {
  const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);
  const conteosFavorables = {};
  const totalPorProducto = {};
  const contextoStats = { MODALITY: {}, SCENARIOS: {}, WASH: {}, PROCESS: {} };

  let totalFilas = 0;
  let totalComparaciones = 0;
  let totalFiltradas = 0;

  Papa.parse(csvFile, {
    header: true,
    skipEmptyLines: true,
    worker: false,
    chunkSize: 1024 * 1024,
    chunk: function(results) {
      const rows = results.data;
      for (const row of rows) {
        totalFilas++;

        const ptestRaw = row["PRODUCT_TEST"];
        const ptest = (ptestRaw || "").trim() || "(EMPTY)";
        if (ptest) {
          totalComparaciones++;
          totalPorProducto[ptest] = (totalPorProducto[ptest] || 0) + 1;
        }

        const resp = (row["RESPONSE"] || "").trim();
        const esFavorable = objetivos.has(resp);

        if (esFavorable) {
          totalFiltradas++;
          if (ptest) conteosFavorables[ptest] = (conteosFavorables[ptest] || 0) + 1;
        }

        for (const ctxName of Object.keys(contextoStats)) {
          const v = ((row[ctxName] || "").trim()) || "(EMPTY)";
          if (!contextoStats[ctxName][v]) contextoStats[ctxName][v] = { total: 0, fav: 0 };
          contextoStats[ctxName][v].total++;
          if (esFavorable) contextoStats[ctxName][v].fav++;
        }
      }
    },
    complete: function() {
      if (!Object.keys(conteosFavorables).length) {
        statusEl.textContent = "❌ No se encontraron filas con RESPONSE favorable.";
        numericEl.textContent = "// Sin resultados favorables para PRODUCT_TEST.";
        textEl.textContent = "// Sin datos suficientes.";
        prepararDatosGrafico(null);
        prepararDatosGraficoMultivariable(null);
        return;
      }

      const totalFavorables = Object.values(conteosFavorables).reduce((s, c) => s + c, 0);
      const tasaGlobal = (totalComparaciones > 0) ? (totalFavorables / totalComparaciones) : 0;

      const formatPct = (v) => (v * 100).toFixed(2) + "%";
      const productos = Object.keys(totalPorProducto).map(prod => {
        const n = totalPorProducto[prod] || 0;
        const k = conteosFavorables[prod] || 0;
        const tasa = n > 0 ? (k / n) : 0;
        const diff = tasa - tasaGlobal;

        let z = null, ciLow = null, ciHigh = null;
        if (n > 0 && tasaGlobal > 0 && tasaGlobal < 1) {
          const se = Math.sqrt(tasaGlobal * (1 - tasaGlobal) / n);
          if (se > 0) {
            z = diff / se;
            const half = 1.96 * se;
            ciLow = tasa - half;
            ciHigh = tasa + half;
          }
        }
        return { prod, n, k, tasa, diff, z, ciLow, ciHigh };
      }).sort((a,b) => b.tasa - a.tasa);

      // contextos críticos (altos/bajos) con z-score aprox
      const contextoResumen = [];
      for (const ctxName of Object.keys(contextoStats)) {
        const mapa = contextoStats[ctxName];
        const arr = Object.entries(mapa).map(([valor, st]) => {
          const tasaCtx = st.total > 0 ? (st.fav / st.total) : 0;
          const diffCtx = tasaCtx - tasaGlobal;
          let z = null;
          if (st.total > 1 && tasaGlobal > 0 && tasaGlobal < 1) {
            const se = Math.sqrt(tasaGlobal * (1 - tasaGlobal) / st.total);
            if (se > 0) z = diffCtx / se;
          }
          return { valor, total: st.total, fav: st.fav, tasa: tasaCtx, diff: diffCtx, z };
        }).filter(x => x.total >= 20);

        const altos = arr.filter(x => x.diff > 0).sort((a,b)=>b.diff-a.diff).slice(0,3);
        const bajos = arr.filter(x => x.diff < 0).sort((a,b)=>a.diff-b.diff).slice(0,3);
        contextoResumen.push({ ctxName, altos, bajos });
      }

      // Sección 5 (tu texto grande)
      let numTxt = "";
      numTxt += "PANORAMA GLOBAL\n";
      numTxt += "--------------\n";
      numTxt += "Total filas: " + totalFilas + "\n";
      numTxt += "Total comparaciones (PRODUCT_TEST): " + totalComparaciones + "\n";
      numTxt += "Total favorables: " + totalFiltradas + "\n";
      numTxt += "Tasa global favorable: " + formatPct(tasaGlobal) + "\n\n";

      numTxt += "DESEMPEÑO POR PRODUCT_TEST (k/n)\n";
      numTxt += "-------------------------------\n";
      numTxt += "Producto | n | k | Tasa | Δ vs global | z | IC95%\n";
      numTxt += "--------|---|---|------|------------|---|------\n";
      productos.forEach(p => {
        const zTxt = (p.z === null) ? "NA" : p.z.toFixed(2);
        let icTxt = "NA";
        if (p.ciLow !== null && p.ciHigh !== null) {
          const lo = Math.max(0, Math.min(1, p.ciLow));
          const hi = Math.max(0, Math.min(1, p.ciHigh));
          icTxt = "[" + formatPct(lo) + " ; " + formatPct(hi) + "]";
        }
        numTxt += `${p.prod} | ${p.n} | ${p.k} | ${formatPct(p.tasa)} | ${(p.diff*100>=0?"+":"")}${(p.diff*100).toFixed(2)} p.p. | ${zTxt} | ${icTxt}\n`;
      });
      numTxt += "\nCONTEXTOS CRÍTICOS (MODALITY/SCENARIOS/WASH/PROCESS)\n";
      numTxt += "---------------------------------------------------\n";
      contextoResumen.forEach(ctx => {
        numTxt += "CTX: " + ctx.ctxName + "\n";
        numTxt += "  ALTOS:\n";
        (ctx.altos.length?ctx.altos:[{valor:"(none)",total:0,fav:0,tasa:0,diff:0,z:null}]).forEach(c=>{
          const zt = (c.z===null||c.z===undefined)?"NA":Number(c.z).toFixed(2);
          numTxt += `    - ${c.valor} | n=${c.total} | fav=${c.fav} | tasa=${formatPct(c.tasa)} | Δ=${(c.diff*100>=0?"+":"")}${(c.diff*100).toFixed(2)} p.p. | z≈${zt}\n`;
        });
        numTxt += "  BAJOS:\n";
        (ctx.bajos.length?ctx.bajos:[{valor:"(none)",total:0,fav:0,tasa:0,diff:0,z:null}]).forEach(c=>{
          const zt = (c.z===null||c.z===undefined)?"NA":Number(c.z).toFixed(2);
          numTxt += `    - ${c.valor} | n=${c.total} | fav=${c.fav} | tasa=${formatPct(c.tasa)} | Δ=${(c.diff*100>=0?"+":"")}${(c.diff*100).toFixed(2)} p.p. | z≈${zt}\n`;
        });
        numTxt += "\n";
      });

      numericEl.textContent = numTxt;

      // gráfico 1
      const ordenadosPorFavorable = Object.entries(conteosFavorables).sort((a, b) => b[1] - a[1]);
      prepararDatosGrafico({
        labels: ordenadosPorFavorable.map(([prod]) => prod),
        values: ordenadosPorFavorable.map(([, cnt]) => cnt),
        datasetLabel: "Resultados favorables",
        title: "Resultados favorables por PRODUCT_TEST",
        xLabel: "PRODUCT_TEST",
        yLabel: "Número de resultados favorables"
      });

      // gráfico 2 multivariable
      prepararDatosGraficoMultivariable({
        labels: productos.map(p => p.prod),
        datasets: [
          { label: "Tasa favorable (%)", values: productos.map(p => p.tasa * 100) },
          { label: "Número total de comparaciones", values: productos.map(p => p.n) }
        ],
        title: "Tasa favorable (%) y nº comparaciones por PRODUCT_TEST",
        xLabel: "PRODUCT_TEST",
        yLabel: "Escala relativa"
      });

      // ✅ Payload estructurado a backend
      const payload = {
        mode: "comparaciones",
        prompt_key: currentPromptKey,
        prompt_text: userPrompt,
        totalFilas: totalFilas,
        totalComparaciones: totalComparaciones,
        totalFavorables: totalFiltradas,
        tasaGlobal: tasaGlobal,
        productos: productos,
        with_titles: true,
        detail_level: 3,
        min_words: 1200,
        contextos: contextoResumen
      };

      pedirExplicacionDesdeBackendStructured(payload);
      statusEl.textContent = "✅ Comparaciones: sección 5 lista. Sección 6 generándose con /build_section6…";
    },
    error: function(err) {
      statusEl.textContent = "❌ Error al leer el CSV: " + err;
      numericEl.textContent = "// Error al procesar el archivo.";
      textEl.textContent = "";
      prepararDatosGrafico(null);
      prepararDatosGraficoMultivariable(null);
    }
  });
}

// -------------------------------------------------------------
// Modo 2: Blancura (lo dejo igual en esencia, solo: arma payload estructurado)
// -------------------------------------------------------------
function analizarBlancura(statusEl, numericEl, textEl, userPrompt) {
  const dataMax = {};
  const globalAgg = {};
  const prodAgg = {};
  const globalCountsMax = {};

  let totalFilas = 0;

  const ensureAgg = (agg, key1, key2) => {
    if (!agg[key1]) agg[key1] = {};
    if (!agg[key1][key2]) agg[key1][key2] = { sum: 0, sumsq: 0, count: 0 };
    return agg[key1][key2];
  };

  Papa.parse(csvFile, {
    header: true,
    skipEmptyLines: true,
    worker: false,
    chunkSize: 1024 * 1024,
    chunk: function(results) {
      const rows = results.data;
      for (const row of rows) {
        totalFilas++;
        const monitor = (row["MONITOR"] || "").trim();
        const product = (row["PRODUCT"] || "").trim();
        if (!monitor || !product) continue;

        for (const m of whitenessMetrics) {
          if (!(m in row)) continue;
          const v = parseFloat(row[m]);
          if (Number.isNaN(v)) continue;

          if (!globalAgg[m]) globalAgg[m] = { sum: 0, sumsq: 0, count: 0 };
          globalAgg[m].sum += v;
          globalAgg[m].sumsq += v * v;
          globalAgg[m].count++;

          const pa = ensureAgg(prodAgg, product, m);
          pa.sum += v;
          pa.sumsq += v * v;
          pa.count++;

          if (!dataMax[monitor]) dataMax[monitor] = {};
          if (!dataMax[monitor][m]) dataMax[monitor][m] = { max: null, rows: [] };
          const entry = dataMax[monitor][m];
          if (entry.max === null || v > entry.max) {
            entry.max = v;
            entry.rows = [{ PRODUCT: product, VALUE: v }];
          } else if (v === entry.max) {
            entry.rows.push({ PRODUCT: product, VALUE: v });
          }
        }
      }
    },
    complete: function() {
      if (!Object.keys(globalAgg).length) {
        statusEl.textContent = "❌ No se encontraron datos válidos de blancura.";
        numericEl.textContent = "// Sin resultados WI.";
        textEl.textContent = "// Sin datos suficientes.";
        prepararDatosGrafico(null);
        prepararDatosGraficoMultivariable(null);
        return;
      }

      const globalStats = {};
      for (const m of Object.keys(globalAgg)) {
        const g = globalAgg[m];
        const mean = g.count > 0 ? (g.sum / g.count) : 0;
        const varv = g.count > 0 ? Math.max(0, (g.sumsq / g.count) - mean * mean) : 0;
        const sd = Math.sqrt(varv);
        globalStats[m] = { mean, sd, count: g.count };
      }

      const productosWhiteness = {};
      for (const product of Object.keys(prodAgg)) {
        const metrics = prodAgg[product];
        for (const m of Object.keys(metrics)) {
          const a = metrics[m];
          const g = globalStats[m];
          if (!g || g.count === 0) continue;
          const meanProd = a.count > 0 ? (a.sum / a.count) : 0;
          const diff = meanProd - g.mean;

          let z = null;
          if (a.count > 1 && g.sd > 0) {
            const se = g.sd / Math.sqrt(a.count);
            if (se > 0) z = diff / se;
          }

          if (!productosWhiteness[m]) productosWhiteness[m] = [];
          productosWhiteness[m].push({ product, n: a.count, mean: meanProd, diff, z });
        }
      }
      for (const m of Object.keys(productosWhiteness)) {
        productosWhiteness[m].sort((a,b)=>b.mean-a.mean);
      }

      // máximos
      for (const monitor of Object.keys(dataMax)) {
        const metricsObj = dataMax[monitor];
        for (const metric of Object.keys(metricsObj)) {
          const info = metricsObj[metric];
          for (const row of info.rows) {
            const prod = row.PRODUCT || "(EMPTY)";
            globalCountsMax[prod] = (globalCountsMax[prod] || 0) + 1;
          }
        }
      }
      const topMaxApariciones = Object.entries(globalCountsMax)
        .sort((a,b)=>b[1]-a[1])
        .map(([product,cnt])=>({product,cnt}));

      // sección 5 (compacta, pero útil)
      let numTxt = "";
      numTxt += "GLOBAL STATS (WI)\n";
      numTxt += "-----------------\n";
      numTxt += "Total filas: " + totalFilas + "\n\n";
      for (const m of whitenessMetrics) {
        const g = globalStats[m];
        if (!g) continue;
        numTxt += `${m} | n=${g.count} | mean≈${g.mean.toFixed(3)} | sd≈${g.sd.toFixed(3)}\n`;
      }
      numTxt += "\nTOP MAX APPEARANCES (by PRODUCT)\n";
      topMaxApariciones.slice(0,20).forEach(x=>{
        numTxt += `  - ${x.product}: ${x.cnt}\n`;
      });

      numericEl.textContent = numTxt;

      prepararDatosGrafico({
        labels: topMaxApariciones.slice(0,30).map(x => x.product),
        values: topMaxApariciones.slice(0,30).map(x => x.cnt),
        datasetLabel: "Max appearances",
        title: "Apariciones como máximo por PRODUCT",
        xLabel: "PRODUCT",
        yLabel: "Count"
      });

      // (opcional) multivariable para whiteness: no lo fuerzo
      prepararDatosGraficoMultivariable(null);

      const payload = {
        mode: "whiteness",
        prompt_key: currentPromptKey,
        prompt_text: userPrompt,
        totalFilas: totalFilas,
        globalStats: globalStats,
        topMaxApariciones: topMaxApariciones,
        with_titles: true,
        detail_level: 3,
        min_words: 1200,
        productosWhiteness: productosWhiteness
      };

      pedirExplicacionDesdeBackendStructured(payload);
      statusEl.textContent = "✅ Blancura: sección 5 lista. Sección 6 generándose con /build_section6…";
    },
    error: function(err) {
      statusEl.textContent = "❌ Error al leer el CSV: " + err;
      numericEl.textContent = "// Error al procesar el archivo.";
      textEl.textContent = "";
      prepararDatosGrafico(null);
      prepararDatosGraficoMultivariable(null);
    }
  });
}

// -------------------------------------------------------------
// Modo 3: Resumen (payload estructurado básico)
// -------------------------------------------------------------
function analizarResumen(statusEl, numericEl, textEl, userPrompt) {
  const stats = {};
  let totalFilas = 0;
  let headersLocal = null;

  Papa.parse(csvFile, {
    header: true,
    skipEmptyLines: true,
    worker: false,
    chunkSize: 1024 * 1024,
    chunk: function(results) {
      const rows = results.data;
      if (!headersLocal) headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
      for (const row of rows) {
        totalFilas++;
        for (const col of Object.keys(row)) {
          if (!stats[col]) stats[col] = { nonEmpty: 0 };
          const v = row[col];
          if (v !== null && v !== undefined && String(v).trim() !== "") stats[col].nonEmpty++;
        }
      }
    },
    complete: function() {
      if (!headersLocal || !headersLocal.length) {
        statusEl.textContent = "❌ No se pudo detectar estructura válida.";
        numericEl.textContent = "// Sin estructura.";
        textEl.textContent = "// Sin datos suficientes.";
        prepararDatosGrafico(null);
        prepararDatosGraficoMultivariable(null);
        return;
      }

      const numCols = headersLocal.length;
      const topDensidad = headersLocal.map(c => ({ col: c, nonEmpty: stats[c]?.nonEmpty || 0 }))
        .sort((a,b)=>b.nonEmpty-a.nonEmpty);

      let numTxt = "";
      numTxt += "TABLE SUMMARY\n";
      numTxt += "------------\n";
      numTxt += "Rows: " + totalFilas + "\n";
      numTxt += "Cols: " + numCols + "\n\n";
      numTxt += "Top non-empty columns:\n";
     topDensidad.slice(0, 20).forEach(x => {
    numTxt += "  - " + x.col + ": " + x.nonEmpty + "\n";
});

      numericEl.textContent = numTxt;

      prepararDatosGrafico({
        labels: topDensidad.slice(0,30).map(x=>x.col),
        values: topDensidad.slice(0,30).map(x=>x.nonEmpty),
        datasetLabel: "Non-empty",
        title: "Valores no vacíos por columna (top)",
        xLabel: "Columns",
        yLabel: "Non-empty count"
      });

      prepararDatosGraficoMultivariable(null);

      const payload = {
        mode: "resumen",
        prompt_key: currentPromptKey,
        prompt_text: userPrompt,
        totalFilas: totalFilas,
        numCols: numCols,
        with_titles: true,
        detail_level: 3,
        min_words: 1200,
        topDensidad: topDensidad
      };

      pedirExplicacionDesdeBackendStructured(payload);
      statusEl.textContent = "✅ Resumen: sección 5 lista. Sección 6 generándose con /build_section6…";
    },
    error: function(err) {
      statusEl.textContent = "❌ Error al leer el CSV: " + err;
      numericEl.textContent = "// Error.";
      textEl.textContent = "";
      prepararDatosGrafico(null);
      prepararDatosGraficoMultivariable(null);
    }
  });
}

// -------------------------------------------------------------
// Modo 4: RESPONSE vs Otras (Prompt 4)
// ✅ ARREGLO: aquí también generamos gráfico multivariable
// ✅ Sección 5 más rica: tasas favorables por columnas clave + contextos críticos
// ✅ Payload compatible con app.py: responseDistribucion [{resp,cnt,pct}] (no pares)
// -------------------------------------------------------------
function analizarResponseVsOtros(statusEl, numericEl, textEl, userPrompt) {
  const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);

  const responseCounts = {};
  const contextoFavStats = {}; // col -> valor -> {total,fav}
  const colNonEmpty = {};      // col -> nonEmpty count
  const colUnique = {};        // col -> Set() de valores (muestreo controlado)
  let totalFilas = 0;
  let headersLocal = null;
  let totalFavorables = 0;

  // Ajustes de heurística (puedes afinarlos)
  const MAX_UNIQUE_TRACK = 4000;   // límite para no explotar memoria
  const MAX_CONTEXT_COLS = 6;      // cuántas columnas usar como "contextos críticos"
  const MIN_NONEMPTY_RATIO = 0.20; // mínimo % no vacío para considerar columna
  const MAX_CARD_RATIO = 0.60;     // máximo % cardinalidad/filas (evita ID únicos)
  const MIN_CARD = 2;             // mínimo cardinalidad
  const MAX_CARD = 80;            // máximo cardinalidad (si supera, probablemente es ID/texto libre)
  const EXCLUDE_COLS = new Set(["RESPONSE"]); // excluimos RESPONSE como contexto (ya es target)

  // Heurística: ¿parece numérica?
  function isProbablyNumeric(sampleValues) {
    // Si la mayoría de muestras parsean a número -> numérica
    let n = 0, ok = 0;
    for (const v of sampleValues) {
      if (v === null || v === undefined) continue;
      const s = String(v).trim();
      if (!s) continue;
      n++;
      const x = Number(s);
      if (!Number.isNaN(x)) ok++;
      if (n >= 30) break; // no hace falta más
    }
    if (n === 0) return false;
    return (ok / n) >= 0.85;
  }

  Papa.parse(csvFile, {
    header: true,
    skipEmptyLines: true,
    worker: false,
    chunkSize: 1024 * 1024,
    chunk: function(results) {
      const rows = results.data;
      if (!headersLocal) {
        headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
        // inicializar estructuras
        headersLocal.forEach(h => {
          colNonEmpty[h] = 0;
          colUnique[h] = new Set();
        });
      }

      for (const row of rows) {
        totalFilas++;

        const resp = ((row["RESPONSE"] || "").trim()) || "(EMPTY)";
        responseCounts[resp] = (responseCounts[resp] || 0) + 1;

        const esFavorable = objetivos.has(resp);
        if (esFavorable) totalFavorables++;

        // recolectar no-vacíos y uniques por columna (para detectar contextos)
        for (const col of headersLocal) {
          const raw = row[col];
          const val = (raw === null || raw === undefined) ? "" : String(raw).trim();
          if (val !== "") {
            colNonEmpty[col]++;

            // track uniques con límite
            const s = colUnique[col];
            if (s && s.size < MAX_UNIQUE_TRACK) s.add(val);
          }
        }
      }
    },
    complete: function() {
      if (!headersLocal || !headersLocal.length) {
        statusEl.textContent = "❌ No se pudo detectar estructura válida.";
        numericEl.textContent = "// Sin estructura.";
        textEl.textContent = "// Sin datos suficientes.";
        prepararDatosGrafico(null);
        prepararDatosGraficoMultivariable(null);
        return;
      }

      const formatPct = (v) => (v * 100).toFixed(2) + "%";
      const tasaGlobalFav = totalFilas > 0 ? (totalFavorables / totalFilas) : 0;

      // -----------------------------
      // 1) Detectar columnas candidatas automáticamente
      // -----------------------------
      const candidates = [];
      for (const col of headersLocal) {
        if (EXCLUDE_COLS.has(col)) continue;

        const nonEmpty = colNonEmpty[col] || 0;
        const nonEmptyRatio = totalFilas > 0 ? (nonEmpty / totalFilas) : 0;
        if (nonEmptyRatio < MIN_NONEMPTY_RATIO) continue;

        const uniqCount = (colUnique[col] ? colUnique[col].size : 0);
        if (uniqCount < MIN_CARD) continue;
        if (uniqCount > MAX_CARD) continue;

        const cardRatio = totalFilas > 0 ? (uniqCount / totalFilas) : 0;
        if (cardRatio > MAX_CARD_RATIO) continue;

        // descartar columnas numéricas (con una mini muestra)
        const sample = [];
        // sacar muestra rápida desde Set (hasta 30)
        let i = 0;
        for (const v of colUnique[col]) { sample.push(v); i++; if (i >= 30) break; }
        if (isProbablyNumeric(sample)) continue;

        // score: más no-vacíos + cardinalidad moderada (premia señal, castiga ruido)
        const score = nonEmptyRatio * 0.7 + (1 - Math.abs(uniqCount - 12) / 12) * 0.3;
        candidates.push({ col, nonEmpty, nonEmptyRatio, uniqCount, score });
      }

      candidates.sort((a,b) => b.score - a.score);
      const selectedCols = candidates.slice(0, MAX_CONTEXT_COLS).map(x => x.col);

      // Si no encontró nada, fallback a tus columnas clave clásicas si existen
      const FALLBACK = ["PRODUCT_TEST","PRODUCT","MONITOR","MODALITY","SCENARIOS","WASH","PROCESS"];
      if (!selectedCols.length) {
        FALLBACK.forEach(c => {
          if (headersLocal.includes(c) && !selectedCols.includes(c) && selectedCols.length < MAX_CONTEXT_COLS) {
            selectedCols.push(c);
          }
        });
      }

      // -----------------------------
      // 2) Ahora sí, reconstruimos contextoFavStats SOLO para selectedCols
      //    (segunda pasada al CSV)
      // -----------------------------
      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(res2) {
          for (const row of res2.data) {
            const resp = ((row["RESPONSE"] || "").trim()) || "(EMPTY)";
            const esFavorable = objetivos.has(resp);

            for (const col of selectedCols) {
              const val = ((row[col] || "").trim()) || "(EMPTY)";
              if (!contextoFavStats[col]) contextoFavStats[col] = {};
              if (!contextoFavStats[col][val]) contextoFavStats[col][val] = { total: 0, fav: 0 };
              contextoFavStats[col][val].total++;
              if (esFavorable) contextoFavStats[col][val].fav++;
            }
          }
        },
        complete: function() {
          // -----------------------------
          // 3) Construir responseDistribucion y topContextos
          // -----------------------------
          const sortedResponses = Object.entries(responseCounts).sort((a,b)=>b[1]-a[1]);

          const responseDistribucion = sortedResponses.map(([r,c]) => ({
            resp: r,
            cnt: c,
            pct: totalFilas>0 ? (c*100/totalFilas) : 0
          }));

          const topContextos = [];
          for (const col of Object.keys(contextoFavStats)) {
            const mapa = contextoFavStats[col];
            const arr = Object.entries(mapa).map(([valor, st]) => {
              const n = st.total;
              const fav = st.fav;
              const tasa = n>0 ? fav/n : 0;
              const diff = tasa - tasaGlobalFav;
              let z = null;
              if (n>1 && tasaGlobalFav>0 && tasaGlobalFav<1) {
                const se = Math.sqrt(tasaGlobalFav*(1-tasaGlobalFav)/n);
                if (se>0) z = diff/se;
              }
              return { valor, total:n, fav, tasa, diff, z };
            }).filter(x => x.total >= 20);

            const altos = arr.filter(x=>x.diff>0).sort((a,b)=>b.diff-a.diff).slice(0,3);
            const bajos = arr.filter(x=>x.diff<0).sort((a,b)=>a.diff-b.diff).slice(0,3);
            topContextos.push({ ctxName: col, altos, bajos });
          }

          // -----------------------------
          // 4) Sección 5: texto (ahora incluye columnas detectadas)
          // -----------------------------
          let numTxt = "";
          numTxt += "RESPONSE DISTRIBUTION\n";
          numTxt += "---------------------\n";
          numTxt += "Total rows: " + totalFilas + "\n";
          numTxt += "Global favorable rate (01.SUPERIOR + 02.SUPERIOR_TREND): " + formatPct(tasaGlobalFav) + "\n\n";

          sortedResponses.forEach(([r,c])=>{
            const pct = totalFilas>0 ? (c*100/totalFilas).toFixed(2)+"%" : "0.00%";
            numTxt += `  - ${r}: ${c} (${pct})\n`;
          });

          numTxt += "\nAUTO-DETECTED CONTEXT COLUMNS\n";
          numTxt += "-----------------------------\n";
          if (selectedCols.length) {
            numTxt += "Selected columns: " + selectedCols.join(", ") + "\n";
          } else {
            numTxt += "No context columns detected (fallback failed).\n";
          }

          numTxt += "\nKEY COLUMNS: FAVORABLE RATES BY VALUE (CRITICAL CONTEXTS)\n";
          numTxt += "--------------------------------------------------------\n";
          numTxt += "Contextos construidos solo con columnas seleccionadas automáticamente (o fallback). n mínimo por valor: 20.\n\n";

          topContextos.forEach(ctx=>{
            numTxt += "CTX COLUMN: " + ctx.ctxName + "\n";
            if (ctx.altos.length) {
              numTxt += "  HIGH (increases favorable probability):\n";
              ctx.altos.forEach(c=>{
                const zt = (c.z===null||c.z===undefined)?"NA":Number(c.z).toFixed(2);
                numTxt += `    - ${c.valor} | n=${c.total} | fav=${c.fav} | rate=${formatPct(c.tasa)} | Δ=${(c.diff*100>=0?"+":"")}${(c.diff*100).toFixed(2)} p.p. | z≈${zt}\n`;
              });
            } else {
              numTxt += "  HIGH: (none with n>=20)\n";
            }
            if (ctx.bajos.length) {
              numTxt += "  LOW (decreases favorable probability):\n";
              ctx.bajos.forEach(c=>{
                const zt = (c.z===null||c.z===undefined)?"NA":Number(c.z).toFixed(2);
                numTxt += `    - ${c.valor} | n=${c.total} | fav=${c.fav} | rate=${formatPct(c.tasa)} | Δ=${(c.diff*100>=0?"+":"")}${(c.diff*100).toFixed(2)} p.p. | z≈${zt}\n`;
              });
            } else {
              numTxt += "  LOW: (none with n>=20)\n";
            }
            numTxt += "\n";
          });

          numericEl.textContent = numTxt;

          // -----------------------------
          // 5) Gráficos
          // -----------------------------
          prepararDatosGrafico({
            labels: sortedResponses.map(([r])=>r),
            values: sortedResponses.map(([,c])=>c),
            datasetLabel: "Rows",
            title: "Distribución de RESPONSE",
            xLabel: "RESPONSE",
            yLabel: "Row count"
          });

          const firstCtx = topContextos.find(x => (x.altos && x.altos.length) || (x.bajos && x.bajos.length));
          if (firstCtx) {
            const combined = []
              .concat(firstCtx.altos || [])
              .concat(firstCtx.bajos || [])
              .slice(0,6);

            prepararDatosGraficoMultivariable({
              labels: combined.map(x => x.valor),
              datasets: [
                { label: "Favorable rate (%)", values: combined.map(x => x.tasa * 100) },
                { label: "n (total rows)", values: combined.map(x => x.total) }
              ],
              title: `Favorable rate (%) and n by ${firstCtx.ctxName} (top contexts)`,
              xLabel: firstCtx.ctxName,
              yLabel: "Rate% / n"
            });
          } else {
            prepararDatosGraficoMultivariable(null);
          }

          // -----------------------------
          // 6) Payload a backend (Prompt 4)
          //    - topContextos ya lleva los nombres reales de columnas detectadas
          // -----------------------------
          const payload = {
            mode: "response_rel",
            prompt_key: currentPromptKey,
            prompt_text: userPrompt,
            totalFilas: totalFilas,
            tasaGlobalFav: tasaGlobalFav,
            responseDistribucion: responseDistribucion,
            with_titles: true,
            detail_level: 3,
            min_words: 1200,
            topContextos: topContextos
          };

          pedirExplicacionDesdeBackendStructured(payload);
          statusEl.textContent = "✅ RESPONSE vs Others: sección 5 lista (columnas detectadas). Sección 6 generándose con /build_section6…";
        },
        error: function(err) {
          statusEl.textContent = "❌ Error al re-leer el CSV: " + err;
          numericEl.textContent = "// Error.";
          textEl.textContent = "";
          prepararDatosGrafico(null);
          prepararDatosGraficoMultivariable(null);
        }
      });
    },
    error: function(err) {
      statusEl.textContent = "❌ Error al leer el CSV: " + err;
      numericEl.textContent = "// Error.";
      textEl.textContent = "";
      prepararDatosGrafico(null);
      prepararDatosGraficoMultivariable(null);
    }
  });
}
  </script>
</body>
</html>
